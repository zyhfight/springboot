# 基于springboot实现的高并发，高可用限时秒杀系统

## 系统介绍 ##
	代码基于SpringBoot框架实现了高并发、高可用限时秒杀系统demo（inspired by immoc）。
	主要实现了登录、商品列表、商品秒杀等模块，demo中主要应用了redis缓存、rabbitMq消息队列、
	前后端分离等，以应对高并发场景，实现系统demo的高可用。
## 工具 ##
	Intellij IDEA + Navicat + Chrome + Visio
## 使用技术 ##
	前端：Bootstrap + jQuery
	后端：SpringBoot + Mybatis
	数据库：MySQL
	中间件：Redis + RabbitMQ + Druid
## 关键技术点 ##
### 1、password两次MD5
	第一次MD5：避免用户密码以明文在网络传输
	第二次MD5：避免数据库数据泄露，通过彩虹表反推出密码
### 2、分布式session
	用户名、密码验证正确前提下，生成唯一标识token作为key，user信息作为value模拟session
	通过redis集中存储；避免分布式集群下，服务期间同步延迟，导致session不一致情况。
### 3、JSR303校验
### 4、全局异常统一处理器
	demo中遇到异常，就逐层往上throw，最终由一个全局异常统一处理器拦截所有异常，并对各类异常进行处理。
### 5、redis缓存
	使用redis缓存user信息、缓存token（实现分布式session）、缓存商品列表、
	缓存商品详情页、缓存订单信息、缓存动态秒杀接口地址、缓存动态验证码等数据；
	充分利用缓存来削减对数据库并发访问、减轻数据库负荷，提高数据查询效率和系统可用性。
### 6、前后端分离
	商品列表、详情和订单详情页面都是纯html，动态数据通过ajax调用后台接口从服务端获取，手动实现最简易的前后端分离
### 7、内存标记 + redis预减库存 + RabbitMQ异步下单 + 客户端轮询
	使用map标记商品是否已被秒杀完毕，若标记为秒杀over，直接返回秒杀完毕，减少redis查询；
	若未被标记，才会查询redis，在秒杀活动开始前，将商品、库存等数据同步到redis中，秒杀时，会通过redis预减库存，以减少对数据库访问；
	用户进行秒杀时，如果判断商品库存存在，会使用RabbitMQ异步下单，系统立即返回排队中，避免高流量冲击，提升用户使用体验；
	client端会调用js函数轮询秒杀结果接口，以获取最终秒杀结果；
### 8、防刷、限流、避免超卖
	秒杀前，需要输入数学公式验证码，验证ok后，才能进行秒杀。
	验证码可以有效防刷、分散用户请求，流量削峰；
	实现@AccessLimit注解，以达到系统限流、降级处理。
	更新库存时，判断库存>0，只有大于0，库存才能更新成功，user id和商品id建立UNIQUE CONSTRRAINT避免重复秒杀；
## 综述 ##
	秒杀商品是典型的读多写少的场景，可以充分利用缓存提升系统并发量；通过防刷、限流、降级提升系统可用性；
	demo inspired by immoc，利用业余时间编写的一个十分简易的秒杀系统demo。
	主要锻炼自己的高并发、高可用系统设计实现能力，相信demo中采用的技术点和实现思路在实际企业应用中也有较大的参考意义。
	（此readme.md编写参考了https://github.com/zaiyunduan123/jesper_seckill）
